package com.belellou.kevin.advent.year2018;

import java.io.BufferedReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang3.tuple.Pair;

import com.belellou.kevin.advent.generic.AbstractDaySolver;

@SuppressWarnings("unused")
public class Day9 extends AbstractDaySolver<Long, Long> {

    private static final Pattern LINE_PATTERN = Pattern.compile("^(\\d+) players; last marble is worth (\\d+) points$");

    private static Pair<Integer, Integer> parseLine(String line) {
        Matcher matcher = LINE_PATTERN.matcher(line);

        if (!matcher.find()) {
            throw new IllegalArgumentException("Invalid line: " + line);
        }

        return Pair.of(Integer.parseInt(matcher.group(1)), Integer.parseInt(matcher.group(2)));
    }

    private static long play(int players, int lastMarble) {
        long[] scores = new long[players];

        List<Integer> circle = new ArrayList<>(lastMarble + 1);
        circle.add(0);

        int currentMarble = 0;

        for (int nextMarble = 1; nextMarble <= lastMarble; nextMarble++) {
            if (nextMarble % 23 == 0) {
                int player = nextMarble % players;
                scores[player] += nextMarble;

                currentMarble = (currentMarble - 7) % circle.size();
                if (currentMarble < 0) {
                    currentMarble += circle.size();
                }

                scores[player] += circle.remove(currentMarble);
            } else {
                int nextIndex = (currentMarble + 2) % circle.size();
                if (nextIndex == 0) {
                    nextIndex = circle.size();
                }
                circle.add(nextIndex, nextMarble);
                currentMarble = nextIndex;
            }
        }

        return Arrays.stream(scores)
                     .max()
                     .orElseThrow();
    }

    // This code has been generated by the AI Junie
    private static long playByAI(int players, int lastMarble) {
        long[] scores = new long[players];

        // build initial circle [0]
        Node current = new Node(0);
        current.prev = current;
        current.next = current;

        for (int nextMarble = 1; nextMarble <= lastMarble; nextMarble++) {
            int player = nextMarble % players;
            if (nextMarble % 23 != 0) {
                // move +2 and insert marble there as current
                current = current.next;           // +1
                // insert between current and current.next
                Node right = current.next;        // +2 position is right
                Node n = new Node(nextMarble);
                n.prev = current;
                n.next = right;
                current.next = n;
                right.prev = n;
                current = n;                      // the newly placed marble
            } else {
                // move -7 and remove that marble
                scores[player] += nextMarble;
                for (int i = 0; i < 7; i++) {
                    current = current.prev;
                }
                scores[player] += current.value;

                // remove current, set current to the node clockwise of the removed one
                Node left = current.prev;
                Node right = current.next;
                left.next = right;
                right.prev = left;
                current = right;
            }
        }

        return Arrays.stream(scores)
                     .max()
                     .orElseThrow();
    }

    @Override
    protected Long doSolveFirstStar(BufferedReader reader) throws IOException {
        Pair<Integer, Integer> pair = parseLine(reader.readLine());
        int players = pair.getLeft();
        int lastMarble = pair.getRight();

        return play(players, lastMarble);
    }

    @Override
    public Long getFirstStarSolution() {
        return 388_844L;
    }

    @Override
    protected Long doSolveSecondStar(BufferedReader reader) throws IOException {
        Pair<Integer, Integer> pair = parseLine(reader.readLine());
        int players = pair.getLeft();
        int lastMarble = pair.getRight() * 100;

        return playByAI(players, lastMarble);
    }

    @Override
    public Long getSecondStarSolution() {
        return 3_212_081_616L;
    }

    private static final class Node {

        public final int value;
        public Node prev, next;

        public Node(int value) {
            this.value = value;
        }
    }
}
